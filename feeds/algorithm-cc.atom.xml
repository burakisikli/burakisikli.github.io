<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title></title><link href="http://www.burakisikli.com/" rel="alternate"></link><link href="http://www.burakisikli.com/feeds/algorithm-cc.atom.xml" rel="self"></link><id>http://www.burakisikli.com/</id><updated>2009-08-14T02:00:00+03:00</updated><entry><title>Dinamik Programlama(Dynamic Programming)</title><link href="http://www.burakisikli.com/dinamik-programlamadynamic-programming.html" rel="alternate"></link><published>2009-08-14T02:00:00+03:00</published><author><name>burakisikli</name></author><id>tag:www.burakisikli.com,2009-08-14:dinamik-programlamadynamic-programming.html</id><summary type="html">&lt;p&gt;Dinamik programlama bir problemi çözerken aynı alt-problemi birden fazla
çözmemiz gereken durumlarda bu alt-problemi birden fazla kez çözmemizi
engelleyen bir tekniktir. Dinamik programalama, matematik ve bilgisayar
bilimlerinde karmaşık problemleri çözmek için kullanılan bir metottur.
&lt;a href="http://en.wikipedia.org/wiki/Overlapping_subproblem" title="Overlapping subproblem"&gt;Overlapping
subproblems&lt;/a&gt;
ve &lt;a href="http://en.wikipedia.org/wiki/Optimal_substructure" title="Optimal substructure"&gt;optimal
substructure&lt;/a&gt;
denilen problemlerde
uygunabiliyor.&lt;a href="http://en.wikipedia.org/wiki/Optimal_substructure" title="Optimal substructure"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Eğer problemimiz kendi içinde alt problemlere ayrılabiliyorsa
overlapping subproblems'dir. Buna en iyi örnek Fibanicci serisidir. Daha
önceden &lt;a href="http://burakisikli.wordpress.com/2009/06/15/fibonacci-serisi/"&gt;bu
yazımda&lt;/a&gt;
fibonacci serisini anlatmıştım.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Shortest Path Optimal
Substructure" class="alignleft
.size-full wp-image-221" height="107" src="http://burakisikli.files.wordpress.com/2009/08/shortest_path_optimal_substructure.png" title="Shortest Path Optimal Substructure" width="200" /&gt;Fakat problemimiz
kendi içinde alt problemlere ayrıldığında daha iyi bir performans
sağlıyorsa buna optimal substructure deniliyor. Buna en iyi örnek ise
greedy algoritmasıdır. Dinamik programlamada geçen programlama sözcüğü
sadece bilgisayar programlarını kapsamamaktadır, çünkü burada
kullandığımız program sözcüğü “matematiksel programlama” dan
gelmektedir, ki bu da kısaca sıkça kullandığımız optimizasyon(bir nevi
iyileştirme demek optimizasyon belki kullanmayan da vardır :) kelimesine
denk gelmektedir.&lt;/p&gt;
&lt;p&gt;Dinamik programlama uygulamalarımızda temel olarak 3 teknikten
faydalanacağız:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Çözümü aynı olan alt-problemler&lt;/li&gt;
&lt;li&gt;Büyük bir problemi küçük parçalara bölmek ve bu küçük parçaları
    kullanarak baştaki büyük problemimizin sonucuna ulaşmak&lt;/li&gt;
&lt;li&gt;Çözdüğümüz her alt-problemin sonucunu bir yere not almak ve
    gerektiğinde bu sonucu kullanarak aynı problemi tekrar tekrar
    çözmeyi engellemek.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Şimdi örneğimiz olan fibonacci dizimize başlayalım. Fibonacci dizimizi
kısaca bir hatırlayalım.&lt;/p&gt;
&lt;p&gt;Eğer herhangi bir sayının Fibonacci karşılığına F(n) dersek,&lt;/p&gt;
&lt;p&gt;F(0) = F(1) = 1 olmak üzere&lt;/p&gt;
&lt;p&gt;F(n) = F(n-1) + F(n-2)'dir.&lt;/p&gt;
&lt;p&gt;İlk yaptığımız prosesimizin fonksiyonunu hatırlayalım:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fib.cpp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br /&gt;
// Recursive Function&lt;br /&gt;
int fib(int num) {&lt;br /&gt;
if ((num == 0) || (num == 1))&lt;br /&gt;
return num;&lt;br /&gt;
else&lt;br /&gt;
return (fib(num - 1) + fib(num - 2));&lt;br /&gt;
}&lt;br /&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Bu kadar kısa bir kod yazarak çözümü sağlamıştık. Ancak bu yöntem kodun
kısa olmasına rağmen performans açısından kötü bir yöntemdir.  Nedenine
gelirsek mesela F(3)'ü adım adım hesaplayalım:&lt;/p&gt;
&lt;p&gt;F(4) = (F(2) + F(1)))&lt;/p&gt;
&lt;p&gt;= ((F(1) + F(0)) + F(1)) + F(2)&lt;/p&gt;
&lt;p&gt;= ((F(1) + F(0)) + F(1)) + (F(1) + F(0))&lt;/p&gt;
&lt;p&gt;Görüldüğü gibi F(4) değerini hesaplarken F(1)'ye 2 defa ihtiyacımız oldu
ama 2 seferde de hesapladık. Prosesimizi değiştirerek bir de şu hale
getirelim.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fib2.cpp&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[sourcecode language=&amp;quot;cpp&amp;quot;]&lt;/span&gt;
&lt;span class="err"&gt;/*&lt;/span&gt;
 &lt;span class="err"&gt;*&lt;/span&gt;
 &lt;span class="err"&gt;*&lt;/span&gt; &lt;span class="err"&gt;Program: &lt;/span&gt; &lt;span class="err"&gt;Fibonacci&lt;/span&gt; &lt;span class="err"&gt;Series&lt;/span&gt; &lt;span class="err"&gt;v2&lt;/span&gt;
 &lt;span class="err"&gt;*&lt;/span&gt; &lt;span class="err"&gt;Programmer:&lt;/span&gt; &lt;span class="err"&gt;Burak&lt;/span&gt; &lt;span class="err"&gt;ISIKLI&lt;/span&gt;
 &lt;span class="err"&gt;*&lt;/span&gt;
 &lt;span class="err"&gt;*/&lt;/span&gt;

&lt;span class="c1"&gt;#include &amp;lt;iostream.h&amp;gt;&lt;/span&gt;

&lt;span class="err"&gt;unsigned&lt;/span&gt; &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;fib2(unsigned&lt;/span&gt; &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;num)&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;

&lt;span class="err"&gt;unsigned&lt;/span&gt; &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;fibArray[1000]&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;

&lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="err"&gt;Main&lt;/span&gt; &lt;span class="err"&gt;Function&lt;/span&gt;
&lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;main()&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
 &lt;span class="err"&gt;unsigned&lt;/span&gt; &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;number,&lt;/span&gt; &lt;span class="err"&gt;result&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
 &lt;span class="na"&gt;cout &amp;lt;&amp;lt; &amp;quot;Fibonacci serisinin(fib(x)) sayisini giriniz x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;;&lt;/span&gt;
&lt;span class="s"&gt; cin &amp;gt;&amp;gt; number;&lt;/span&gt;

 &lt;span class="na"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;fib2(number);&lt;/span&gt;
&lt;span class="s"&gt; cout &amp;lt;&amp;lt; &amp;quot;fib( &amp;quot; &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot; ) = &amp;quot; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; &amp;quot;\n\n&amp;quot;;&lt;/span&gt;

 &lt;span class="err"&gt;return&lt;/span&gt; &lt;span class="err"&gt;0&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;

&lt;span class="err"&gt;unsigned&lt;/span&gt; &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;fib2(unsigned&lt;/span&gt; &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;num)&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;
 &lt;span class="na"&gt;unsigned int i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;2;&lt;/span&gt;
&lt;span class="s"&gt; fibArray[0] = fibArray[1] = 1;&lt;/span&gt;
&lt;span class="s"&gt; while(i &amp;lt;= num)&lt;/span&gt;
&lt;span class="s"&gt; {&lt;/span&gt;
&lt;span class="s"&gt; fibArray[i] = fibArray[i - 1] + fibArray[i - 2];&lt;/span&gt;
&lt;span class="s"&gt; i++;&lt;/span&gt;
&lt;span class="s"&gt; }&lt;/span&gt;
&lt;span class="s"&gt; return fibArray[num];&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;[/sourcecode]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Burada yaptığımız işlem ise şu. Hesapladığımız Fibonacci sayılarını bir
diziye kaydediyoruz. Daha sonra lazım olunca bu değerleri direkt diziden
hazır bi şekilde alıyoruz. Böylece aynı işlemi tekrar tekrar yapmaktan
kurtuluyoruz.&lt;/p&gt;
&lt;p&gt;Performans karşılaştırması yapacak olursak kendi bilgisayarımda
fibonacci(50) 8dk. 36 sn'de sonuç verirken fibonacci2(50) 0.003 sn'de
sonuç veriyor. Daha bilimsel konuşacak olursak problemi temelde aynı
mantıkla çalışan iki fonksiyonun birincisi O(2\^n) iken ikincisi O(n)
zamanda çözmektedir.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kaynaklar:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Dynamic_programming"&gt;http://en.wikipedia.org/wiki/Dynamic_programming&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Optimal_substructure"&gt;http://en.wikipedia.org/wiki/Optimal_substructure&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://e-bergi.com/2008/Mart/Dinamik-Programlama"&gt;http://e-bergi.com/2008/Mart/Dinamik-Programlama&lt;/a&gt;&lt;/p&gt;
&lt;div id="_mcePaste"
style="overflow:hidden;position:absolute;left:-10000px;top:1557px;width:1px;height:1px;"&gt;

    [sourcecode language="cpp"]
    /*
     *
     * Program:  Fibonacci Series v2
     * Programmer: Burak ISIKLI
     *
     */

    #include &lt;iostream.h&gt;

    unsigned int fib2(unsigned int num);

    unsigned int fibArray[1000];

    // Main Function
    int main() {
     unsigned int number, result;
     cout &lt;&lt; "Fibonacci serisinin(fib(x)) sayisini giriniz x = ";
     cin &gt;&gt; number;

     result = fib2(number);
     cout &lt;&lt; "fib( " &lt;&lt; number &lt;&lt; " ) = " &lt;&lt; result &lt;&lt; "\n\n";

     return 0;
    }

    unsigned int fib2(unsigned int num)
    {
     unsigned int i = 2;
     fibArray[0] = fibArray[1] = 1;
     while(i &lt;= num)
     {
     fibArray[i] = fibArray[i - 1] + fibArray[i - 2];
     i++;
     }
     return fibArray[num];
    }

    [/sourcecode]

&lt;/div&gt;</summary><category term="Dinamik"></category><category term="Dinamik Programlama"></category><category term="Dynamic"></category><category term="Fibonacci"></category><category term="Optimal Substructure"></category><category term="Overlapping Subproblems"></category><category term="Programlama"></category><category term="Programming"></category><category term="Rekürsif"></category><category term="Serisi"></category></entry><entry><title>Asal Sayı(Prime Number) Algoritması:</title><link href="http://www.burakisikli.com/asal-sayiprime-number-algoritmasi.html" rel="alternate"></link><published>2009-07-24T02:26:00+03:00</published><author><name>burakisikli</name></author><id>tag:www.burakisikli.com,2009-07-24:asal-sayiprime-number-algoritmasi.html</id><summary type="html">&lt;p&gt;Bir forumda gördüğüm konu üzerine ufak bir araştırma yaptım. Konuda asal
sayıların bulma algoritmasının nasıl olacağı soruluyordu. Bu soru iki
şekilde anlaşılabilir. Birincisi verilen sayının asal sayı olup
olmadığı, ikincisi ise verilen sayı aralığındaki bütün asal sayıların
bulunmasıdır. Öncelikle asal sayının ne olduğunu hatırlayalım.&lt;/p&gt;
&lt;p&gt;'&lt;em&gt;Asal sayılar'&lt;/em&gt;, yalnız ve yalnız iki böleni olan doğal sayılardır.
Kendisinden ve 1 sayısından başka böleni olmayan, 1'den büyük pozitif
tam sayılar biçiminde de tanımlanmaktadır.(kendisinden küçük asal
sayıların hiçbirine tam bölünmeyen sayılardır) Yüzden küçük asal sayılar
2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,
71, 73, 79, 83, 89 ve 97 dir. Tam listesi için &lt;a href="http://tr.wikipedia.org/wiki/Asal_say%C4%B1lar_listesi"&gt;burayı
tıklayın.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Şimdi birinci algoritmamızı yapalım. Bu algoritmada tanımdan gidiyoruz.
“Sayı kendisinden ve 1’den başka sayıya bölünemez”. Boolean fonksiyonu
ve for döngüsü yardımıyla herhangi bir sayıyı bölündüğünü yakaladığımız
takdirde false döndürerek asal sayı olmadığına karar veriyoruz. Bu
algoritmanın çözüm karmaşıklığı &lt;em&gt;O(&lt;strong&gt;&lt;em&gt;√&lt;/em&gt;&lt;/strong&gt;n)&lt;/em&gt;’dir.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prime.cpp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br /&gt;
/*&lt;br /&gt;
* Process:  Prime Number&lt;br /&gt;
* Programmer: Burak ISIKLI&lt;br /&gt;
*&lt;br /&gt;
*/&lt;/p&gt;
&lt;p&gt;#include&amp;lt;iostream.h&amp;gt;&lt;/p&gt;
&lt;p&gt;bool isPrimeNumber(long int num);&lt;/p&gt;
&lt;p&gt;int main() {&lt;br /&gt;
long int number;&lt;br /&gt;
cout &amp;lt;&amp;lt; "Find primes: ";&lt;br /&gt;
cin &amp;gt;&amp;gt; number;&lt;/p&gt;
&lt;p&gt;if (isPrimeNumber(number))&lt;br /&gt;
cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; number &amp;lt;&amp;lt; ", is a prime number"
&amp;lt;&amp;lt; endl;&lt;br /&gt;
else&lt;br /&gt;
cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; number &amp;lt;&amp;lt; ", isn't a prime number"
&amp;lt;&amp;lt; endl;&lt;/p&gt;
&lt;p&gt;return 0;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;bool isPrimeNumber(long int num) {&lt;br /&gt;
for (long int i = 2; i &amp;lt; num; i++) {&lt;br /&gt;
if (num % i == 0)&lt;br /&gt;
return false;&lt;br /&gt;
}&lt;br /&gt;
return true;&lt;br /&gt;
}&lt;br /&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Bu prosesimiz bize Çözmek istediğimiz sayıyı soruyor. Öğrenmek
istediğimiz sayıyı girdiğimizde sayının asal olup olmadığını söylüyor.&lt;/p&gt;
&lt;p&gt;Peki ama bu algoritmayı daha verimli yapamaz mıyız? Elbette yapabiliriz.
Eğer n sayımızın şu şekilde bir fonksiyon aralığında olduğunu düşünürsek
&lt;strong&gt;d (1 &amp;lt; d &amp;lt; n)&lt;/strong&gt; ve bu fonksiyonun tamamının karekökünü alırsak
&lt;strong&gt;d~0~ (1 &amp;lt; d~0~ &amp;lt; √n)&lt;/strong&gt; &lt;strong&gt;ş&lt;/strong&gt;eklinde bir fonksiyon elde ederiz.
Eğer n sayımızın tamamen karekökü alınabiliyorsa mükemmel karedir ancak
asal değildir. Aksi halde farzedelimki ilk bulduğumuz bölüm &lt;strong&gt;d~1~,  √n
&amp;lt; d~1~ &amp;lt; n&lt;/strong&gt; olsun. Ama n, √n’den az olan &lt;strong&gt;d~2~ = n / d~1~&lt;/strong&gt;
tarafından tamamen bölünüyor. Bu nedenle tahmin yanlıştır ve eğer
&lt;strong&gt;&lt;span style="font-weight:normal;"&gt;√n’den daha büyük bir bölen varsa o
zaman çifti √n’den azdır. Böylelikle ifademiz kanıtlanmış oldu.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Son olarak kodumuzu vermeden bir iyileştirmeden daha bahsetmeliyim. Farz
edelimki n tek bir sayı(2 bölen olamaz) olsun. Eğer n 2’ye kalansız
bölünemiyorsa başka hiçbir çift sayıya tamamen bölünemez. İşte bu
iyileştirmeden sonra değişen algoritmamız ve prosesimiz şu şekilde
oluyor:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prime.v2.cpp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br /&gt;
/*&lt;br /&gt;
* Process:  Prime Number&lt;br /&gt;
* Programmer: Burak ISIKLI&lt;br /&gt;
*&lt;br /&gt;
*/&lt;/p&gt;
&lt;p&gt;#include&amp;lt;iostream.h&amp;gt;&lt;br /&gt;
#include&amp;lt;math.h&amp;gt;&lt;/p&gt;
&lt;p&gt;bool isPrimeNumber(long int num);&lt;/p&gt;
&lt;p&gt;int main() {&lt;br /&gt;
long int number;&lt;br /&gt;
cout &amp;lt;&amp;lt; "Find primes: ";&lt;br /&gt;
cin &amp;gt;&amp;gt; number;&lt;/p&gt;
&lt;p&gt;if (isPrimeNumber(number))&lt;br /&gt;
cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; number &amp;lt;&amp;lt; ", is a prime number"
&amp;lt;&amp;lt; endl;&lt;br /&gt;
else&lt;br /&gt;
cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; number &amp;lt;&amp;lt; ", isn't a prime number"
&amp;lt;&amp;lt; endl;&lt;/p&gt;
&lt;p&gt;return 0;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;bool isPrimeNumber(long int num) {&lt;br /&gt;
if (number == 2)&lt;br /&gt;
return true;&lt;br /&gt;
if (number % 2 == 0)&lt;br /&gt;
return false;&lt;br /&gt;
for (long int i = 3; i &amp;lt;= (long int) sqrt((double) num); i++) {&lt;br /&gt;
if (num % i == 0)&lt;br /&gt;
return false;&lt;br /&gt;
}&lt;br /&gt;
return true;&lt;br /&gt;
}&lt;br /&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Bu algoritmamızın iyileştirmelerden sonraki çözüm karmaşıklığı &lt;em&gt;O(√n /
ln(n))&lt;/em&gt; oldu.&lt;/p&gt;
&lt;p&gt;İkinci algoritma girilen sayı aralığına kadar asal sayıları listeleme.
Aslında bunun için özelleşmiş spesifik bir algoritma mevcut. &lt;strong&gt;“Sieve
Algoritması”&lt;/strong&gt; adı verilen algoritmanın çözüm karmaşıklığı
&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;^1\ /\ 2^loglog&lt;em&gt;n&lt;/em&gt; / log&lt;em&gt;n&lt;/em&gt;)’dir.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sieve.cpp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;/p&gt;
&lt;p&gt;/*&lt;br /&gt;
* Process:  Prime Number - Sieve Algorithm&lt;br /&gt;
* Programmer: Burak ISIKLI&lt;br /&gt;
*&lt;br /&gt;
*/&lt;/p&gt;
&lt;p&gt;#include &amp;lt;iostream.h&amp;gt;&lt;br /&gt;
#include &amp;lt;math.h&amp;gt;&lt;br /&gt;
#include &amp;lt;assert.h&amp;gt;&lt;br /&gt;
#include &amp;lt;time.h&amp;gt;&lt;/p&gt;
&lt;p&gt;int main() {&lt;br /&gt;
int i;&lt;br /&gt;
clock_t start, stop;&lt;br /&gt;
double t = 0.0;&lt;br /&gt;
cout &amp;lt;&amp;lt; "Find primes up to: ";&lt;br /&gt;
cin &amp;gt;&amp;gt; i;&lt;/p&gt;
&lt;p&gt;assert((start = clock())!=-1);&lt;/p&gt;
&lt;p&gt;//create prime list&lt;br /&gt;
int prime[i];&lt;br /&gt;
int c1, c2, c3;&lt;/p&gt;
&lt;p&gt;//fill list with 0 - prime&lt;br /&gt;
for (c1 = 2; c1 &amp;lt;= i; c1++) {&lt;br /&gt;
prime[c1] = 0;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;//set 0 and 1 as not prime&lt;br /&gt;
prime[0] = 1;&lt;br /&gt;
prime[1] = 1;&lt;/p&gt;
&lt;p&gt;//find primes then eliminate their multiples (0 = prime, 1 = composite)&lt;br /&gt;
for (c2 = 2; c2 &amp;lt;= (int) sqrt(i) + 1; c2++) {&lt;br /&gt;
if (prime[c2] == 0) {&lt;br /&gt;
c1 = c2;&lt;br /&gt;
for (c3 = 2 * c1; c3 &amp;lt;= i + 1; c3 = c3 + c1) {&lt;br /&gt;
prime[c3] = 1;&lt;br /&gt;
}&lt;br /&gt;
}&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;stop = clock();&lt;br /&gt;
t = stop - start;&lt;/p&gt;
&lt;p&gt;//print primes&lt;br /&gt;
for (c1 = 0; c1 &amp;lt; i + 1; c1++) {&lt;br /&gt;
if (prime[c1] == 0)&lt;br /&gt;
cout &amp;lt;&amp;lt; c1 &amp;lt;&amp;lt; "\t";&lt;br /&gt;
}&lt;br /&gt;
cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; "Run time: " &amp;lt;&amp;lt; t &amp;lt;&amp;lt; endl;
//print time to find primes&lt;/p&gt;
&lt;p&gt;return 0;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Bu prosesimiz bize hangi sayıya kadar bulmak istediğimizi soruyor.
Sayıyı girdiğimiz takdirde asal sayıları listeleyip çalışma süresini
yazıyor.&lt;/p&gt;
&lt;p&gt;Asal sayılar özellikle şifreleme(cryptography) alanında sıkça kullanılan
bir konudur. Örneğin bizden 100 basamaklı asal sayı üretilmesi istense,
görünüş olarak algoritmamız iyi bir zamanda sayıları kontrol edemez.
İşte bu nedenle bizim algoritmamız pratikte kullanılmak amacıyla
uygulanmıştır. Ancak büyük sayıların asal olup olmadığını test etmek
istediğimizde olasılıksal algoritma(probabilistic algorithm) kullanılır.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kaynaklar:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://tr.wikipedia.org/wiki/Asal_say%C4%B1"&gt;http://tr.wikipedia.org/wiki/Asal_say%C4%B1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"&gt;http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.dreamincode.net/code/snippet3315.htm"&gt;http://www.dreamincode.net/code/snippet3315.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://mathworld.wolfram.com/PrimeNumber.html"&gt;http://mathworld.wolfram.com/PrimeNumber.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.algolist.net/Algorithms/Number_theoretic_algorithms/Sieve_of_Eratosthenes"&gt;http://www.algolist.net/Algorithms/Number_theoretic_algorithms/Sieve_of_Eratosthenes&lt;/a&gt;&lt;/p&gt;</summary><category term="Asal"></category><category term="Asal Sayı"></category><category term="Cryptography"></category><category term="Prime"></category><category term="Prime Number"></category><category term="Sieve"></category><category term="Sieve Algorithm"></category><category term="Sieve of Eratosthenes"></category><category term="Şifreleme"></category></entry><entry><title>Faktoriyel(Factorial) Bulma</title><link href="http://www.burakisikli.com/faktoriyelfactorial-bulma.html" rel="alternate"></link><published>2009-06-15T02:14:00+03:00</published><author><name>burakisikli</name></author><id>tag:www.burakisikli.com,2009-06-15:faktoriyelfactorial-bulma.html</id><summary type="html">&lt;p&gt;Rekürsif fonksiyolarda kullanılan en sık örneklerden biri de faktoriyel
bulmadır. Bildiğiniz üzere faktoriyel örneğin 5
faktoriyel=5!=5*4*3*2*1 şeklinde sayıdan geriye giderek 0'a kadar
çarpılır. Ancak 0! ve 1! 1'e eşittir.&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;/p&gt;
&lt;p&gt;// Program:  Factorial Number&lt;br /&gt;
// Programmer: Burak ISIKLI&lt;/p&gt;
&lt;p&gt;#include &lt;iostream.h&gt;&lt;/p&gt;
&lt;p&gt;// Prototype Function&lt;br /&gt;
int fac(int num);&lt;/p&gt;
&lt;p&gt;// Main Function&lt;br /&gt;
int main()&lt;br /&gt;
{&lt;br /&gt;
int number, result;&lt;br /&gt;
cout &amp;lt;&amp;lt; "Lutfen hesaplatacaginiz sayiyi giriniz: x!= ";&lt;br /&gt;
cin &amp;gt;&amp;gt; number;&lt;br /&gt;
result = fac(number);&lt;br /&gt;
cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; "! = " &amp;lt;&amp;lt; result &amp;lt;&amp;lt; "\n\n";&lt;br /&gt;
return 0;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;// Recursive Function&lt;br /&gt;
int fac(int num)&lt;br /&gt;
{&lt;br /&gt;
if(num == 0 || num == 1)&lt;br /&gt;
return 1;&lt;br /&gt;
else&lt;br /&gt;
return num * fac(num-1);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Kullanıcıya sayıyı sorup hesaplatıp ekrana yazdıran basit bir faktoriyel
bulma programıdır.&lt;/p&gt;</summary><category term="Factorial"></category><category term="Faktoriyel"></category><category term="Number"></category><category term="Recursion"></category><category term="Rekürsif"></category><category term="Sayı"></category></entry><entry><title>Fibonacci Serisi</title><link href="http://www.burakisikli.com/fibonacci-serisi.html" rel="alternate"></link><published>2009-06-15T00:44:00+03:00</published><author><name>burakisikli</name></author><id>tag:www.burakisikli.com,2009-06-15:fibonacci-serisi.html</id><summary type="html">&lt;p&gt;Recursive(Rekürsif) fonksiyonlar öğretilirken en çok kullanılan örnek
fibonacci serisidir. Bu seri özeldir. Serinin ilk iki değeri 0 ve 1'dir.
Sonrasında ise hesaplanacak sayının bir ve iki eksiğinin
fonksiyonlarındaki değerlerinde toplanmasıyla oluşur. Başarılı bir
fibonacci serisi 1.618....'a yakınsar. Buna altın oran(golden ratio) 
veya altın ortalama(golden mean) denir. 0, 1, 1, 2, 3, 5, 8, 13, 21, ...
şeklinde devam eden serinin matematiksel fonksiyonu şu şekildedir:&lt;/p&gt;
&lt;p&gt;fibonacci(0) = 0&lt;/p&gt;
&lt;p&gt;fibonacci(1) = 1&lt;/p&gt;
&lt;p&gt;fibonacci(&lt;span&gt;n&lt;/span&gt;) = fibonacci(&lt;span&gt;n&lt;/span&gt;-1) +
fibonacci(&lt;span&gt;n&lt;/span&gt;-2)&lt;/p&gt;
&lt;p&gt;&lt;img alt="Fibonacci" class="aligncenter
.size-full wp-image-141" height="190" src="http://burakisikli.files.wordpress.com/2009/06/foxtrot20051011.jpg" title="Fibonacci" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;Bu fonksiyonun kodu:&lt;/p&gt;
&lt;p&gt;[sourcecode language="cpp"]&lt;br /&gt;
// Program:  Fibonacci Series&lt;br /&gt;
// Programmer: Burak ISIKLI&lt;/p&gt;
&lt;p&gt;#include &lt;iostream.h&gt;&lt;/p&gt;
&lt;p&gt;// Prototype Function&lt;br /&gt;
int fib(int num);&lt;/p&gt;
&lt;p&gt;// Main Function&lt;br /&gt;
int main() {&lt;br /&gt;
int number, result;&lt;br /&gt;
cout &amp;lt;&amp;lt; "Fibonacci serisinin(fib(x)) sayisini giriniz x = ";&lt;br /&gt;
cin &amp;gt;&amp;gt; number;&lt;/p&gt;
&lt;p&gt;result = fib(number);&lt;br /&gt;
cout &amp;lt;&amp;lt; "fib( " &amp;lt;&amp;lt; number &amp;lt;&amp;lt; " ) = " &amp;lt;&amp;lt; result
&amp;lt;&amp;lt; "\n\n";&lt;/p&gt;
&lt;p&gt;return 0;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;// Recursive Function&lt;br /&gt;
int fib(int num) {&lt;br /&gt;
if ((num == 0) || (num == 1))&lt;br /&gt;
return num;&lt;br /&gt;
else&lt;br /&gt;
return (fib(num - 1) + fib(num - 2));&lt;br /&gt;
}&lt;br /&gt;
[/sourcecode]&lt;/p&gt;
&lt;p&gt;Bu programımızda kullanıcıya hesaplatmak istediği fibonacci değerini
soruyoruz. Hesaplatarak ekrana yazdırıyoruz.&lt;/p&gt;</summary><category term="Fibonacci"></category><category term="Recursive"></category><category term="Rekürsif"></category><category term="Serisi"></category></entry></feed>